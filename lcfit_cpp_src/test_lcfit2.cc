#include "catch.hpp"

#include <iostream>
#include "lcfit.h"
#include "lcfit2.h"

TEST_CASE("simple curves are fitted correctly", "[simple_curves]") {
    SECTION("when the curve is a parabola") {
        const double t0 = 0.1;

        auto f = [t0](double t) {
            return -pow(t - t0, 2.0) - 1000.0;
        };

        std::vector<double> t{t0 / 2.0, t0, t0 + t0 / 2.0};
        std::vector<double> lnl(t.size());

        for (size_t i = 0; i < t.size(); ++i) {
            lnl[i] = f(t[i]);
        }

        const double d1 = 0.0;
        const double d2 = -2.0;

        lcfit2_bsm_t fit_model = {1100, 800, t0, d1, d2};

        lcfit2_rescale(t0, f(t0), &fit_model);
        lcfit2_fit(t.size(), t.data(), lnl.data(), &fit_model);

        std::cout << "model = { "
                  << fit_model.c << ", "
                  << fit_model.m << ", "
                  << fit_model.t0 << ", "
                  << fit_model.d2 << " }\n";

        for (size_t i = 0; i < t.size(); ++i) {
            REQUIRE(lcfit2_lnl(t[i], &fit_model) == Approx(lnl[i]));
        }
    }

    SECTION("when the curve is generated by lcfit") {
        bsm_t true_model = {1200.0, 800.0, 2.0, 0.5};

        auto f = [&true_model](double t) {
            return lcfit_bsm_log_like(t, &true_model);
        };

        const double t0 = lcfit_bsm_ml_t(&true_model);

        std::vector<double> t{0.0, lcfit_bsm_ml_t(&true_model), lcfit_bsm_infl_t(&true_model)};
        std::vector<double> lnl(t.size());

        for (size_t i = 0; i < t.size(); ++i) {
            lnl[i] = f(t[i]);
        }

        auto d2f = [&true_model](double t) {
            const double& c = true_model.c;
            const double& m = true_model.m;
            const double& r = true_model.r;
            const double& b = true_model.b;

            const double theta = exp(r * (t + b));

            const double d2 = ((c - m)*pow(r, 2)*pow(theta, 3) - 2*(c + m)*pow(r, 2)*pow(theta, 2) + (c - m)*pow(r, 2)*theta)/(pow(theta, 4) - 2*pow(theta, 2) + 1); // correct
            //const double d2 = r * r * theta * ((c - m) * pow(theta + 1.0, 2.0) - 2.0 * (c + m) * theta) / pow(theta * theta - 1.0, 2.0); // incorrect

            return d2;
        };

        const double d1 = 0.0;
        double d2 = d2f(t0);

        //
        // FOR TESTING ONLY
        //

        std::cout << "d2 = " << d2 << " -> ";
        //d2 *= 1.0; // FOR TESTING ONLY 801 800
        //d2 *= 1.478992; // FOR TESTING ONLY 1100 800
        //d2 *= 1.714287; // FOR TESTING ONLY 1200 800
        //d2 *= 2.01942; // FOR TESTING ONLY 1300 800
        //d2 *= 2.434790; // FOR TESTING ONLY 1400 800

        std::cout << d2 << "\n";

        //
        //
        //

        lcfit2_bsm_t fit_model = {1100.0, 800.0, t0, d1, d2};

        lcfit2_rescale(t0, f(t0), &fit_model);
        lcfit2_fit(t.size(), t.data(), lnl.data(), &fit_model);

        std::cout << "model = { "
                  << fit_model.c << ", "
                  << fit_model.m << ", "
                  << fit_model.t0 << ", "
                  << fit_model.d2 << " }\n";

        for (size_t i = 0; i < t.size(); ++i) {
            REQUIRE(lcfit2_lnl(t[i], &fit_model) == Approx(lnl[i]));
        }
    }
}
